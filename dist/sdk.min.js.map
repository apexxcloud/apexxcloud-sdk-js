{"version":3,"file":"sdk.min.js","sources":["../src/sdk.js"],"sourcesContent":["class ApexxCloud {\n  constructor(config = {}) {\n    this.config = {\n      baseUrl: config.baseUrl || \"https://api.apexxcloud.com\",\n    };\n\n    // Initialize API clients\n    this.files = {\n      upload: this.uploadFile.bind(this),\n      uploadMultipart: this.uploadMultipart.bind(this),\n    };\n  }\n\n  /**\n   * Uploads a file using multipart upload strategy, suitable for large files.\n   * @param {File} file - The file to upload\n   * @param {Function} getSignedUrl - Callback function to get signed URLs for different upload phases\n   * @param {Object} options - Upload configuration options\n   * @param {Function} [options.onProgress] - Progress callback function\n   * @param {Function} [options.onPartComplete] - Callback function called when each part is uploaded\n   * @param {Function} [options.onComplete] - Callback function called when upload is complete\n   * @param {Function} [options.onError] - Error callback function\n   * @param {number} [options.partSize=5242880] - Size of each part in bytes (default: 5MB)\n   * @param {AbortSignal} [options.signal] - AbortSignal to cancel the upload\n   * @param {number} [options.concurrency=3] - Number of concurrent part uploads\n   * @returns {Promise<Object>} Upload completion response\n   * @throws {Error} If upload fails or is aborted\n   */\n  async uploadMultipart(\n    file,\n    getSignedUrl,\n    {\n      onProgress = () => {},\n      onPartComplete = () => {},\n      onComplete = () => {},\n      onError = () => {},\n      partSize = 5 * 1024 * 1024,\n      signal,\n      concurrency = 3,\n    } = {}\n  ) {\n    let uploadId;\n    let activeXHRs = new Set();\n\n    const cleanup = () => {\n      activeXHRs.forEach((xhr) => xhr.abort());\n      activeXHRs.clear();\n    };\n\n    signal?.addEventListener(\"abort\", () => {\n      cleanup();\n      onError({\n        type: \"abort\",\n        error: new Error(\"Upload aborted\"),\n        phase: \"upload\",\n        timestamp: new Date(),\n      });\n    });\n\n    try {\n      // Start multipart upload\n      const startUrl = await getSignedUrl(\"start-multipart\", {\n        key: file.name,\n        totalParts: Math.ceil(file.size / partSize),\n        mimeType: file.type,\n      });\n\n      const startUpload = () =>\n        new Promise((resolve, reject) => {\n          const xhr = new XMLHttpRequest();\n          activeXHRs.add(xhr);\n\n          if (signal?.aborted) {\n            onError({\n              type: \"abort\",\n              error: new Error(\"Upload aborted\"),\n              phase: \"start\",\n              timestamp: new Date(),\n            });\n            reject(new Error(\"Upload aborted\"));\n            return;\n          }\n\n          xhr.open(\"POST\", startUrl);\n          xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\n          xhr.onload = () => {\n            activeXHRs.delete(xhr);\n            if (xhr.status >= 200 && xhr.status < 300) {\n              const response = JSON.parse(xhr.responseText);\n              resolve(JSON.parse(xhr.responseText));\n            } else {\n              const error = new Error(\n                `Start upload failed with status ${xhr.status}`\n              );\n              onError({\n                type: \"error\",\n                error,\n                phase: \"start\",\n                status: xhr.status,\n                timestamp: new Date(),\n              });\n              reject(error);\n            }\n          };\n\n          xhr.onerror = () => {\n            activeXHRs.delete(xhr);\n            const error = new Error(\"Start upload failed\");\n            onError({\n              type: \"error\",\n              error,\n              phase: \"start\",\n              timestamp: new Date(),\n            });\n            reject(error);\n          };\n\n          xhr.send(\n            JSON.stringify({\n              filename: file.name,\n              contentType: file.type,\n              size: file.size,\n            })\n          );\n        });\n\n      const response = await startUpload();\n      const uploadId = response.data.uploadId;\n      // Calculate parts\n      const totalParts = Math.ceil(file.size / partSize);\n      const parts = [];\n      let uploadedBytes = 0;\n\n      // Upload parts with concurrency control\n      const uploadPart = async (partNumber) => {\n        const start = (partNumber - 1) * partSize;\n        const end = Math.min(start + partSize, file.size);\n        const chunk = file.slice(start, end);\n\n        const partUrl = await getSignedUrl(\"uploadpart\", {\n          uploadId,\n          partNumber,\n          key: file.name,\n          totalParts,\n        });\n\n        return new Promise((resolve, reject) => {\n          const xhr = new XMLHttpRequest();\n          activeXHRs.add(xhr);\n\n          if (signal?.aborted) {\n            reject(new Error(\"Upload aborted\"));\n            return;\n          }\n\n          xhr.upload.onprogress = (event) => {\n            if (event.lengthComputable) {\n              const partProgress = event.loaded / event.total;\n              const partSize = end - start;\n              const partLoaded = partSize * partProgress;\n              const totalProgress =\n                ((uploadedBytes + partLoaded) / file.size) * 100;\n\n              onProgress({\n                loaded: uploadedBytes + partLoaded,\n                total: file.size,\n                progress: totalProgress,\n                part: {\n                  number: partNumber,\n                  progress: partProgress * 100,\n                },\n              });\n            }\n          };\n\n          xhr.open(\"POST\", partUrl);\n\n          xhr.onload = () => {\n            activeXHRs.delete(xhr);\n            if (xhr.status >= 200 && xhr.status < 300) {\n              try {\n                const response = JSON.parse(xhr.responseText);\n                const partData = response.data;\n\n                uploadedBytes += chunk.size;\n\n                const part = {\n                  ETag: partData.ETag,\n                  PartNumber: partData.partNumber,\n                };\n\n                onPartComplete(part);\n                resolve(part);\n              } catch (e) {\n                const error = new Error(\n                  \"Invalid JSON response from upload part\"\n                );\n                onError({\n                  type: \"error\",\n                  error,\n                  phase: \"upload\",\n                  partNumber,\n                  status: xhr.status,\n                  timestamp: new Date(),\n                });\n                reject(error);\n              }\n            } else {\n              let errorMessage;\n              try {\n                const errorResponse = JSON.parse(xhr.responseText);\n                errorMessage =\n                  errorResponse.message ||\n                  `Part upload failed with status ${xhr.status}`;\n              } catch (e) {\n                errorMessage =\n                  xhr.responseText ||\n                  `Part upload failed with status ${xhr.status}`;\n              }\n\n              const error = new Error(errorMessage);\n              onError({\n                type: \"error\",\n                error,\n                phase: \"upload\",\n                partNumber,\n                status: xhr.status,\n                timestamp: new Date(),\n              });\n              reject(error);\n            }\n          };\n\n          xhr.onerror = () => {\n            activeXHRs.delete(xhr);\n            reject(new Error(\"Part upload failed\"));\n          };\n          const formData = new FormData();\n          formData.append(\"file\", chunk, file.name);\n          xhr.send(formData);\n        });\n      };\n\n      // Upload parts with concurrency control\n      for (let i = 0; i < totalParts; i += concurrency) {\n        const partNumbers = Array.from(\n          { length: Math.min(concurrency, totalParts - i) },\n          (_, index) => i + index + 1\n        );\n\n        const uploadedParts = await Promise.all(\n          partNumbers.map((partNumber) => uploadPart(partNumber))\n        );\n        parts.push(...uploadedParts);\n      }\n\n      // Complete upload\n      const completeUrl = await getSignedUrl(\"completemultipart\", {\n        uploadId,\n        key: file.name,\n      });\n\n      const completeUpload = () =>\n        new Promise((resolve, reject) => {\n          const xhr = new XMLHttpRequest();\n          activeXHRs.add(xhr);\n\n          xhr.open(\"POST\", completeUrl);\n          xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\n          // Add upload progress handler\n          xhr.upload.onprogress = (event) => {\n            if (event.lengthComputable) {\n              onProgress({\n                loaded: file.size, // At this point, all parts are uploaded\n                total: file.size,\n                progress: 100, // Complete\n                phase: \"complete\",\n                type: \"progress\",\n              });\n            }\n          };\n\n          xhr.onload = () => {\n            activeXHRs.delete(xhr);\n            if (xhr.status >= 200 && xhr.status < 300) {\n              const response = JSON.parse(xhr.responseText);\n              onProgress({\n                loaded: file.size,\n                total: file.size,\n                progress: 100,\n                phase: \"complete\",\n                type: \"progress\",\n              });\n              onComplete({\n                type: \"complete\",\n                response,\n                timestamp: new Date(),\n                file: {\n                  name: file.name,\n                  size: file.size,\n                  type: file.type,\n                },\n              });\n              resolve(response);\n            } else {\n              reject(\n                new Error(`Complete upload failed with status ${xhr.status}`)\n              );\n            }\n          };\n\n          xhr.onerror = () => {\n            activeXHRs.delete(xhr);\n            reject(new Error(\"Complete upload failed\"));\n          };\n          xhr.send(\n            JSON.stringify({\n              parts: parts.sort((a, b) => a.PartNumber - b.PartNumber),\n            })\n          );\n        });\n\n      return await completeUpload();\n    } catch (error) {\n      cleanup();\n      // If something goes wrong and we have an uploadId, try to cancel the upload\n      if (uploadId) {\n        try {\n          const cancelUrl = await getSignedUrl(\"cancelmultipart\", {\n            uploadId,\n            key: file.name,\n          });\n\n          await new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            xhr.open(\"DELETE\", cancelUrl);\n            xhr.onload = () => (xhr.status < 300 ? resolve() : reject());\n            xhr.onerror = () => reject();\n            xhr.send();\n          });\n        } catch (cancelError) {\n          console.error(\"Failed to cancel multipart upload:\", cancelError);\n        }\n      }\n\n      onError({\n        type: \"error\",\n        error,\n        phase: \"upload\",\n        timestamp: new Date(),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Uploads a file using single request strategy, suitable for smaller files.\n   * @param {File} file - The file to upload\n   * @param {Function} getSignedUrl - Callback function to get signed URL for upload\n   * @param {Object} options - Upload configuration options\n   * @param {Function} [options.onProgress] - Progress callback function\n   * @param {Function} [options.onComplete] - Callback function called when upload is complete\n   * @param {Function} [options.onError] - Error callback function\n   * @param {Function} [options.onStart] - Callback function called when upload starts\n   * @param {AbortSignal} [options.signal] - AbortSignal to cancel the upload\n   * @returns {Promise<Object>} Upload completion response\n   * @throws {Error} If upload fails or is aborted\n   */\n  async uploadFile(\n    file,\n    getSignedUrl,\n    {\n      onProgress = () => {},\n      onComplete = () => {},\n      onError = () => {},\n      onStart = () => {},\n      signal,\n    } = {}\n  ) {\n    try {\n      // Get signed URL for upload\n      const signedUrl = await getSignedUrl(\"upload\", {\n        key: file.name,\n        mimeType: file.type,\n      });\n\n      const xhr = new XMLHttpRequest();\n\n      if (signal?.aborted) {\n        onError({\n          type: \"abort\",\n          error: new Error(\"Upload aborted\"),\n          timestamp: new Date(),\n        });\n        throw new Error(\"Upload aborted\");\n      }\n\n      signal?.addEventListener(\"abort\", () => {\n        xhr.abort();\n        onError({\n          type: \"abort\",\n          error: new Error(\"Upload aborted\"),\n          timestamp: new Date(),\n        });\n      });\n\n      // Return promise for upload completion\n      return new Promise((resolve, reject) => {\n        xhr.open(\"PUT\", signedUrl);\n\n        // Setup progress tracking\n        xhr.upload.onprogress = (event) => {\n          if (event.lengthComputable) {\n            const percentComplete = (event.loaded / event.total) * 100;\n            onProgress({\n              loaded: event.loaded,\n              total: event.total,\n              progress: percentComplete,\n              type: \"progress\",\n            });\n          }\n        };\n\n        // Setup start handler\n        xhr.upload.onloadstart = () => {\n          onStart({\n            type: \"start\",\n            timestamp: new Date(),\n            file: {\n              name: file.name,\n              size: file.size,\n              type: file.type,\n            },\n          });\n        };\n\n        // Setup completion handler\n        xhr.onload = () => {\n          if (xhr.status >= 200 && xhr.status < 300) {\n            try {\n              const response = JSON.parse(xhr.responseText);\n              onComplete({\n                type: \"complete\",\n                response,\n                timestamp: new Date(),\n                file: {\n                  name: file.name,\n                  size: file.size,\n                  type: file.type,\n                },\n              });\n              resolve(response);\n            } catch (e) {\n              onComplete({\n                type: \"complete\",\n                response: xhr.responseText,\n                timestamp: new Date(),\n                file: {\n                  name: file.name,\n                  size: file.size,\n                  type: file.type,\n                },\n              });\n              resolve(xhr.responseText);\n            }\n          } else {\n            const error = new Error(`Upload failed with status ${xhr.status}`);\n            onError({\n              type: \"error\",\n              error,\n              status: xhr.status,\n              timestamp: new Date(),\n            });\n            reject(error);\n          }\n        };\n\n        xhr.onerror = () => {\n          const error = new Error(\"Upload failed\");\n          onError({\n            type: \"error\",\n            error,\n            timestamp: new Date(),\n          });\n          reject(error);\n        };\n\n        xhr.onabort = () => {\n          const error = new Error(\"Upload aborted\");\n          onError({\n            type: \"abort\",\n            error,\n            timestamp: new Date(),\n          });\n          reject(error);\n        };\n\n        // Create FormData and send\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        xhr.send(formData);\n      });\n    } catch (error) {\n      onError({\n        type: \"error\",\n        error,\n        timestamp: new Date(),\n      });\n      throw error;\n    }\n  }\n}\n\nexport default ApexxCloud;\n"],"names":["constructor","config","this","baseUrl","files","upload","uploadFile","bind","uploadMultipart","file","getSignedUrl","onProgress","onPartComplete","onComplete","onError","partSize","signal","concurrency","activeXHRs","Set","cleanup","forEach","xhr","abort","clear","addEventListener","type","error","Error","phase","timestamp","Date","startUrl","key","name","totalParts","Math","ceil","size","mimeType","startUpload","Promise","resolve","reject","XMLHttpRequest","add","aborted","open","setRequestHeader","onload","delete","status","JSON","parse","responseText","onerror","send","stringify","filename","contentType","uploadId","data","parts","uploadedBytes","uploadPart","async","start","partNumber","end","min","chunk","slice","partUrl","onprogress","event","lengthComputable","partProgress","loaded","total","partLoaded","totalProgress","progress","part","number","partData","ETag","PartNumber","e","errorMessage","message","formData","FormData","append","i","partNumbers","Array","from","length","_","index","uploadedParts","all","map","push","completeUrl","completeUpload","response","sort","a","b","onStart","signedUrl","percentComplete","onloadstart","onabort"],"mappings":"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"}